以下では、事前フェッチ（loader）とコンポーネント内フェッチ（TanStack Query）を「どちらを選ぶべきか」の判断基準とベストプラクティスの観点でまとめます。中立的な視点と私見を併記しています。

## 1. 判断基準

| 判断軸 | 事前フェッチ（loader） | コンポーネント内フェッチ（TanStack Query） |
| --- | --- | --- |
| 初回ロード UX | ルート遷移前にデータ取得 → 遷移後すぐ表示可能。初回の白画面やフラッシュが少ない。 | 遷移後に useQuery が走るため、ローディング表示が必要。 |
| データ依存の明示性 | ルート定義で依存データを一覧できる → メンテナンス時に把握しやすい。 | データ取得ロジックが各コンポーネントに分散しやすい → 全体把握には工夫が必要。 |
| フェッチタイミングの柔軟性 | 常にルート遷移時にフェッチされる。遷移後に再フェッチ制御は別実装が必要。 | ユーザー操作やフォーカス時など任意のタイミングで refetch() 可能。 |
| エラーハンドリング | ルート定義の errorElement で一元管理できる。 | 各コンポーネントで onError／エラーUI を用意する必要がある。 |
| キャッシュ活用 | loader ではライブラリ外のキャッシュ制御。別途 SWR や QueryClient を組み合わせる場合も。 | TanStack Query の強力なキャッシュ・ステール・リフェッチ戦略をそのまま活用可能。 |
| コード量・複雑度 | ルート設定が肥大化しやすい。 | ルート定義はシンプル。取得ロジックはフック化すればコンポーネントは薄く保てる。 |

## 2. ベストプラクティス

### 2.1 事前フェッチを採用すべきケース

- **初回表示の UX 重視**  
  顧客向けプロダクトで、画面遷移の「ちらつき」を極力排除したい場合。

- **ルートごとに必須データが固定**  
  例えば、ダッシュボード全体の統計データなど、常に最初に取得しておくべきデータ。

- **認証／権限ガードをルート単位で完結**  
  未認証時リダイレクトや 403 ページ表示をルート定義にまとめたいとき。

### 2.2 コンポーネント内フェッチ（TanStack Query）を採用すべきケース

- **インタラクティブな追加フェッチ**  
  「もっと読む」や「ページネーション」「リアルタイム更新」など、ユーザー操作に応じた再フェッチ。

- **キャッシュ・再フェッチ戦略を活かしたい**  
  画面遷移をまたいでもキャッシュを使いたい、バックグラウンドで自動更新したい場合。

- **コードの関心分離**  
  取得ロジックを useTodo() のようなカスタムフックに切り出し、UI コンポーネントは薄く保ちたい場合。

### 2.3 ハイブリッド採用のすすめ

多くの現場では以下のパターンを採用しています。

「ページ初期表示に必要な最小限データは loader、インタラクティブな追加操作は TanStack Query」